name: CI/CD

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: autorepair
  EKS_CLUSTER_NAME: autorepair-cluster
  K8S_NAMESPACE: autorepair

jobs:
  # ===========================================================
  # Job 1: Lint, Test, Coverage
  # ===========================================================
  build-and-test:
    runs-on: ubuntu-latest

    services:
      db:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: admin
          POSTGRES_PASSWORD: secret
          POSTGRES_DB: autorepair
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.23'

    - name: Install dependencies
      run: go mod download

    - name: Lint
      uses: golangci/golangci-lint-action@v6
      with:
        version: latest
        args: --timeout=5m

    - name: Install migrate
      run: |
        curl -L https://github.com/golang-migrate/migrate/releases/download/v4.16.2/migrate.linux-amd64.tar.gz | tar xvz
        sudo mv migrate /usr/bin/migrate

    - name: Run Migrations
      run: migrate -path migrations -database "postgres://admin:secret@localhost:5432/autorepair?sslmode=disable" up

    - name: Run Tests with Coverage
      run: |
        go test -v -coverpkg=./internal/... -coverprofile=coverage.out -tags=integration ./tests/...
        grep -v -E "docs/|cmd/|seeds/" coverage.out > coverage_filtered.out
        go tool cover -func=coverage_filtered.out
        go tool cover -html=coverage_filtered.out -o coverage.html

    - name: Upload Coverage Report
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report
        path: coverage.html

    - name: Check Coverage Threshold
      run: |
        COVERAGE=$(go tool cover -func=coverage_filtered.out | grep total | awk '{print substr($3, 1, length($3)-1)}')
        echo "Total Coverage: $COVERAGE%"
        if (( $(echo "$COVERAGE < 80.0" | bc -l) )); then
          echo "::warning::Coverage is below 80%!"
        fi

  # ===========================================================
  # Job 2: Build & Push Docker Image to ECR
  # ===========================================================
  docker-build-push:
    runs-on: ubuntu-latest
    needs: build-and-test
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}

    permissions:
      id-token: write
      contents: read

    steps:
    - uses: actions/checkout@v4

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: ecr-login
      uses: aws-actions/amazon-ecr-login@v2

    - name: Extract metadata
      id: meta
      run: |
        ECR_REGISTRY=${{ steps.ecr-login.outputs.registry }}
        IMAGE_TAG=${GITHUB_SHA::8}
        echo "tags=${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG},${ECR_REGISTRY}/${ECR_REPOSITORY}:latest" >> $GITHUB_OUTPUT
        echo "image=${ECR_REGISTRY}/${ECR_REPOSITORY}" >> $GITHUB_OUTPUT
        echo "sha_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        target: production
        push: true
        tags: |
          ${{ steps.ecr-login.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ steps.meta.outputs.sha_tag }}
          ${{ steps.ecr-login.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest

  # ===========================================================
  # Job 3: Deploy to EKS
  # ===========================================================
  deploy:
    runs-on: ubuntu-latest
    needs: docker-build-push
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    permissions:
      id-token: write
      contents: read

    steps:
    - uses: actions/checkout@v4

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: ecr-login
      uses: aws-actions/amazon-ecr-login@v2

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

    - name: Install migrate
      run: |
        curl -L https://github.com/golang-migrate/migrate/releases/download/v4.16.2/migrate.linux-amd64.tar.gz | tar xvz
        sudo mv migrate /usr/bin/migrate

    - name: Run DB Migrations
      run: |
        # Port-forward to RDS via a temporary pod (or use a migration Job)
        kubectl run migrate-job --rm -i --restart=Never \
          --namespace=${{ env.K8S_NAMESPACE }} \
          --image=${{ steps.ecr-login.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest \
          --env="DB_URL=${{ secrets.DB_URL }}" \
          -- /bin/sh -c "migrate -path /app/migrations -database \$DB_URL up" || true

    - name: Deploy to Kubernetes
      run: |
        ECR_REGISTRY=${{ steps.ecr-login.outputs.registry }}
        IMAGE_TAG=${GITHUB_SHA::8}

        # Apply base and production manifests
        kubectl apply -f k8s/base/
        kubectl apply -f k8s/production/

        # Update the deployment image to the newly built one
        kubectl set image deployment/autorepair-api \
          autorepair-api=${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG} \
          --namespace=${{ env.K8S_NAMESPACE }}

    - name: Verify deployment
      run: |
        kubectl rollout status deployment/autorepair-api \
          --namespace=${{ env.K8S_NAMESPACE }} \
          --timeout=300s

    - name: Show deployment info
      if: always()
      run: |
        echo "=== Pods ==="
        kubectl get pods --namespace=${{ env.K8S_NAMESPACE }}
        echo "=== Services ==="
        kubectl get svc --namespace=${{ env.K8S_NAMESPACE }}

  # ===========================================================
  # Job 4: Release (tag-based, runs on main push)
  # ===========================================================
  release:
    runs-on: ubuntu-latest
    needs: deploy
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    permissions:
      contents: write

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Bump version and push tag
      id: tag
      uses: anothrNick/github-tag-action@1.67.0
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        DEFAULT_BUMP: patch
        WITH_V: true

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.tag.outputs.new_tag }}
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
