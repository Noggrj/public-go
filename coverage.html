
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/noggrj/autorepair/cmd/api/main.go (0.0%)</option>
				
				<option value="file1">github.com/noggrj/autorepair/docs/docs.go (0.0%)</option>
				
				<option value="file2">github.com/noggrj/autorepair/internal/identity/delivery/http/handler.go (92.3%)</option>
				
				<option value="file3">github.com/noggrj/autorepair/internal/identity/domain/user.go (100.0%)</option>
				
				<option value="file4">github.com/noggrj/autorepair/internal/identity/infrastructure/repository.go (100.0%)</option>
				
				<option value="file5">github.com/noggrj/autorepair/internal/inventory/domain/part.go (90.0%)</option>
				
				<option value="file6">github.com/noggrj/autorepair/internal/inventory/infrastructure/part_repository.go (100.0%)</option>
				
				<option value="file7">github.com/noggrj/autorepair/internal/notification/infrastructure/console_email_service.go (100.0%)</option>
				
				<option value="file8">github.com/noggrj/autorepair/internal/notification/infrastructure/mock_email_service.go (0.0%)</option>
				
				<option value="file9">github.com/noggrj/autorepair/internal/platform/auth/jwt.go (84.2%)</option>
				
				<option value="file10">github.com/noggrj/autorepair/internal/platform/config/config.go (100.0%)</option>
				
				<option value="file11">github.com/noggrj/autorepair/internal/platform/db/db.go (0.0%)</option>
				
				<option value="file12">github.com/noggrj/autorepair/internal/platform/errors/errors.go (100.0%)</option>
				
				<option value="file13">github.com/noggrj/autorepair/internal/platform/middleware/auth.go (100.0%)</option>
				
				<option value="file14">github.com/noggrj/autorepair/internal/service/application/order_service.go (96.4%)</option>
				
				<option value="file15">github.com/noggrj/autorepair/internal/service/delivery/http/client_handler.go (66.7%)</option>
				
				<option value="file16">github.com/noggrj/autorepair/internal/service/delivery/http/order_handler.go (71.6%)</option>
				
				<option value="file17">github.com/noggrj/autorepair/internal/service/delivery/http/vehicle_handler.go (83.3%)</option>
				
				<option value="file18">github.com/noggrj/autorepair/internal/service/domain/client.go (100.0%)</option>
				
				<option value="file19">github.com/noggrj/autorepair/internal/service/domain/order.go (100.0%)</option>
				
				<option value="file20">github.com/noggrj/autorepair/internal/service/domain/service.go (100.0%)</option>
				
				<option value="file21">github.com/noggrj/autorepair/internal/service/domain/vehicle.go (80.0%)</option>
				
				<option value="file22">github.com/noggrj/autorepair/internal/service/infrastructure/client_repository.go (0.0%)</option>
				
				<option value="file23">github.com/noggrj/autorepair/internal/service/infrastructure/order_repository.go (0.0%)</option>
				
				<option value="file24">github.com/noggrj/autorepair/internal/service/infrastructure/service_repository.go (0.0%)</option>
				
				<option value="file25">github.com/noggrj/autorepair/internal/service/infrastructure/vehicle_repository.go (0.0%)</option>
				
				<option value="file26">github.com/noggrj/autorepair/internal/sharedkernel/doc.go (100.0%)</option>
				
				<option value="file27">github.com/noggrj/autorepair/internal/sharedkernel/plate.go (100.0%)</option>
				
				<option value="file28">github.com/noggrj/autorepair/seeds/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "log"
        "net/http"

        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
        "github.com/go-chi/cors"
        httpSwagger "github.com/swaggo/http-swagger"

        _ "github.com/noggrj/autorepair/docs" // for swagger docs
        identityHttp "github.com/noggrj/autorepair/internal/identity/delivery/http"
        identityInfra "github.com/noggrj/autorepair/internal/identity/infrastructure"
        inventoryInfra "github.com/noggrj/autorepair/internal/inventory/infrastructure"
        notificationInfra "github.com/noggrj/autorepair/internal/notification/infrastructure"
        "github.com/noggrj/autorepair/internal/platform/config"
        "github.com/noggrj/autorepair/internal/platform/db"
        authMiddleware "github.com/noggrj/autorepair/internal/platform/middleware"
        serviceApp "github.com/noggrj/autorepair/internal/service/application"
        serviceHttp "github.com/noggrj/autorepair/internal/service/delivery/http"
        serviceInfra "github.com/noggrj/autorepair/internal/service/infrastructure"
)

// @version 1.0
// @description API for AutoRepair Shop Management System
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.email support@autorepair.com

// @license.name Proprietary
// @license.url http://autorepair.com/license

// @host localhost:8080
// @BasePath /
// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
func main() <span class="cov0" title="0">{
        // 1. Load Config
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load config: %v", err)
        }</span>

        // 2. Connect to DB
        <span class="cov0" title="0">database, err := db.New(cfg.DBURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to database: %v", err)
        }</span>
        <span class="cov0" title="0">defer database.Close()

        // 3. Setup Repositories
        userRepo := identityInfra.NewPostgresUserRepository(database.Pool)
        clientRepo := serviceInfra.NewPostgresClientRepository(database.Pool)
        vehicleRepo := serviceInfra.NewPostgresVehicleRepository(database.Pool)
        partRepo := inventoryInfra.NewPostgresPartRepository(database.Pool)
        serviceRepo := serviceInfra.NewPostgresServiceRepository(database.Pool)
        orderRepo := serviceInfra.NewPostgresOrderRepository(database.Pool)

        emailService := notificationInfra.NewConsoleEmailService()
        // ... other repos

        // 4. Setup Services
        orderService := serviceApp.NewOrderService(orderRepo, partRepo, clientRepo, emailService)

        // 5. Setup Handlers
        authHandler := identityHttp.NewAuthHandler(userRepo)
        clientHandler := serviceHttp.NewClientHandler(clientRepo)
        vehicleHandler := serviceHttp.NewVehicleHandler(vehicleRepo)
        partHandler := serviceHttp.NewPartHandler(partRepo)
        serviceHandler := serviceHttp.NewServiceHandler(serviceRepo)
        orderHandler := serviceHttp.NewOrderHandler(orderRepo, partRepo, serviceRepo, orderService)
        // ... other handlers

        // 6. Setup Router
        r := chi.NewRouter()
        r.Use(middleware.Logger)
        r.Use(middleware.Recoverer)
        r.Use(cors.Handler(cors.Options{
                AllowedOrigins:   []string{"*"},
                AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
                AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
                ExposedHeaders:   []string{"Link"},
                AllowCredentials: true,
                MaxAge:           300,
        }))

        // Swagger
        r.Get("/swagger/*", httpSwagger.Handler(
                httpSwagger.URL(fmt.Sprintf("http://localhost:%s/swagger/doc.json", cfg.Port)),
        ))

        // Routes
        r.Group(func(r chi.Router) </span><span class="cov0" title="0">{
                // Public Routes
                r.Get("/orders/{id}/track", orderHandler.TrackOrder)

                r.Mount("/auth", func() http.Handler </span><span class="cov0" title="0">{
                        sr := chi.NewRouter()
                        authHandler.RegisterRoutes(sr)
                        return sr
                }</span>())

                <span class="cov0" title="0">r.Group(func(r chi.Router) </span><span class="cov0" title="0">{
                        r.Use(authMiddleware.AuthMiddleware)
                        r.Mount("/admin", func() http.Handler </span><span class="cov0" title="0">{
                                sr := chi.NewRouter()
                                sr.Post("/clients", clientHandler.Create)
                                sr.Get("/clients", clientHandler.List)

                                sr.Post("/vehicles", vehicleHandler.Create)
                                sr.Get("/vehicles", vehicleHandler.ListByClient)

                                sr.Post("/parts", partHandler.Create)
                                sr.Get("/parts", partHandler.List)

                                sr.Post("/services", serviceHandler.Create)
                                sr.Get("/services", serviceHandler.List)

                                sr.Post("/orders", orderHandler.Create)
                                sr.Get("/orders/{id}", orderHandler.Get)
                                sr.Patch("/orders/{id}/approve", orderHandler.Approve)
                                sr.Post("/orders/{id}/diagnosis:start", orderHandler.StartDiagnosis)
                                sr.Post("/orders/{id}/budget:send", orderHandler.SendBudget)
                                sr.Post("/orders/{id}/finish", orderHandler.FinishOrder)
                                sr.Post("/orders/{id}/deliver", orderHandler.DeliverOrder)
                                sr.Patch("/orders/{id}/status", orderHandler.UpdateStatus)

                                sr.Get("/reports/revenue", orderHandler.ReportRevenue)
                                sr.Get("/reports/avg-execution-time", orderHandler.ReportAvgExecutionTime)

                                return sr
                        }</span>())
                })
        })

        <span class="cov0" title="0">log.Printf("Starting server on port %s", cfg.Port)
        if err := http.ListenAndServe(":"+cfg.Port, r); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Server failed: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {
            "name": "API Support",
            "email": "support@autorepair.com"
        },
        "license": {
            "name": "Proprietary",
            "url": "http://autorepair.com/license"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/admin/clients": {
            "get": {
                "description": "List all clients",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "clients"
                ],
                "summary": "List Clients",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "additionalProperties": true
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            },
            "post": {
                "description": "Register a new client",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "clients"
                ],
                "summary": "Create Client",
                "parameters": [
                    {
                        "description": "Client Details",
                        "name": "client",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/http.CreateClientRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid input",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/admin/orders": {
            "post": {
                "description": "Create a new service order",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "orders"
                ],
                "summary": "Create Order",
                "parameters": [
                    {
                        "description": "Order Request",
                        "name": "order",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/http.CreateOrderRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid input",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/admin/orders/{id}": {
            "get": {
                "description": "Get details of a specific order",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "orders"
                ],
                "summary": "Get Order",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Order ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid order ID",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "404": {
                        "description": "Order not found",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/admin/orders/{id}/approve": {
            "patch": {
                "description": "Approve an order and reserve parts",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "orders"
                ],
                "summary": "Approve Order",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Order ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "400": {
                        "description": "Invalid order ID",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "409": {
                        "description": "Insufficient stock",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/admin/orders/{id}/budget:send": {
            "post": {
                "description": "Send budget to the client for approval",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "orders"
                ],
                "summary": "Send Budget",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Order ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "400": {
                        "description": "Invalid order ID",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/admin/orders/{id}/deliver": {
            "post": {
                "description": "Mark order as delivered to client",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "orders"
                ],
                "summary": "Deliver Order",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Order ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "400": {
                        "description": "Invalid order ID",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/admin/orders/{id}/diagnosis:start": {
            "post": {
                "description": "Start the diagnosis process for an order",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "orders"
                ],
                "summary": "Start Diagnosis",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Order ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "400": {
                        "description": "Invalid order ID",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/admin/orders/{id}/finish": {
            "post": {
                "description": "Mark order as finished (Completed)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "orders"
                ],
                "summary": "Finish Order",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Order ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "400": {
                        "description": "Invalid order ID",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/admin/orders/{id}/status": {
            "patch": {
                "description": "Update status of an order",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "orders"
                ],
                "summary": "Update Order Status",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Order ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "New Status",
                        "name": "status",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/http.UpdateStatusRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "400": {
                        "description": "Invalid input",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/admin/parts": {
            "get": {
                "description": "List all parts",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "parts"
                ],
                "summary": "List Parts",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "additionalProperties": true
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            },
            "post": {
                "description": "Register a new part",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "parts"
                ],
                "summary": "Create Part",
                "parameters": [
                    {
                        "description": "Part Details",
                        "name": "part",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/http.CreatePartRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid input",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/admin/reports/avg-execution-time": {
            "get": {
                "description": "Get average execution time of orders (In Execution -\u003e Completed)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "reports"
                ],
                "summary": "Report Avg Execution Time",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/admin/reports/revenue": {
            "get": {
                "description": "Get total revenue report",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "reports"
                ],
                "summary": "Report Revenue",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/admin/services": {
            "get": {
                "description": "List all services",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "services"
                ],
                "summary": "List Services",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "additionalProperties": true
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            },
            "post": {
                "description": "Register a new service (labor)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "services"
                ],
                "summary": "Create Service",
                "parameters": [
                    {
                        "description": "Service Details",
                        "name": "service",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/http.CreateServiceRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid input",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/admin/vehicles": {
            "get": {
                "description": "List vehicles by client",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "vehicles"
                ],
                "summary": "List Vehicles",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Client ID",
                        "name": "client_id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "additionalProperties": true
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid client ID",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            },
            "post": {
                "description": "Register a new vehicle",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "vehicles"
                ],
                "summary": "Create Vehicle",
                "parameters": [
                    {
                        "description": "Vehicle Details",
                        "name": "vehicle",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/http.CreateVehicleRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid input",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/auth/login": {
            "post": {
                "description": "Login with email and password to get a JWT token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Login",
                "parameters": [
                    {
                        "description": "Login Request",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/http.loginRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/http.loginResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/errors.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/errors.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/auth/refresh": {
            "post": {
                "description": "Use a refresh token to get a new access token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Refresh Access Token",
                "parameters": [
                    {
                        "description": "Refresh Token Request",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/http.refreshTokenRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/http.loginResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/errors.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/errors.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/auth/register": {
            "post": {
                "description": "Register a new user with name, email, password and role",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Register a new user",
                "parameters": [
                    {
                        "description": "Register Request",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/http.registerRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/domain.User"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/errors.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/errors.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/orders/{id}/track": {
            "get": {
                "description": "Track the status of an order (Public)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "public"
                ],
                "summary": "Track Order",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Order ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/http.OrderTrackingResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid order ID",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "404": {
                        "description": "Order not found",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "domain.Role": {
            "type": "string",
            "enum": [
                "admin",
                "manager",
                "employee"
            ],
            "x-enum-varnames": [
                "RoleAdmin",
                "RoleManager",
                "RoleEmployee"
            ]
        },
        "domain.User": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "password": {
                    "description": "Hashed",
                    "type": "string"
                },
                "role": {
                    "$ref": "#/definitions/domain.Role"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "errors.ErrorResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                }
            }
        },
        "http.CreateClientRequest": {
            "type": "object",
            "properties": {
                "document": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "phone": {
                    "type": "string"
                }
            }
        },
        "http.CreateOrderItemRequest": {
            "type": "object",
            "properties": {
                "quantity": {
                    "type": "integer"
                },
                "ref_id": {
                    "type": "string"
                },
                "type": {
                    "description": "\"service\" or \"part\"",
                    "type": "string"
                }
            }
        },
        "http.CreateOrderRequest": {
            "type": "object",
            "properties": {
                "client_id": {
                    "type": "string"
                },
                "items": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/http.CreateOrderItemRequest"
                    }
                },
                "vehicle_id": {
                    "type": "string"
                }
            }
        },
        "http.CreatePartRequest": {
            "type": "object",
            "properties": {
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "price": {
                    "type": "number"
                },
                "stock_qty": {
                    "type": "integer"
                }
            }
        },
        "http.CreateServiceRequest": {
            "type": "object",
            "properties": {
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "price": {
                    "type": "number"
                }
            }
        },
        "http.CreateVehicleRequest": {
            "type": "object",
            "properties": {
                "brand": {
                    "type": "string"
                },
                "client_id": {
                    "type": "string"
                },
                "model": {
                    "type": "string"
                },
                "plate": {
                    "type": "string"
                },
                "year": {
                    "type": "integer"
                }
            }
        },
        "http.OrderTrackingItem": {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string"
                },
                "quantity": {
                    "type": "integer"
                },
                "total": {
                    "type": "number"
                }
            }
        },
        "http.OrderTrackingResponse": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "items": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/http.OrderTrackingItem"
                    }
                },
                "status": {
                    "type": "string"
                },
                "total": {
                    "type": "number"
                }
            }
        },
        "http.UpdateStatusRequest": {
            "type": "object",
            "properties": {
                "status": {
                    "type": "string"
                }
            }
        },
        "http.loginRequest": {
            "type": "object",
            "properties": {
                "email": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "http.loginResponse": {
            "type": "object",
            "properties": {
                "access_token": {
                    "type": "string"
                },
                "expires_in": {
                    "type": "integer"
                },
                "refresh_token": {
                    "type": "string"
                }
            }
        },
        "http.refreshTokenRequest": {
            "type": "object",
            "properties": {
                "refresh_token": {
                    "type": "string"
                }
            }
        },
        "http.registerRequest": {
            "type": "object",
            "properties": {
                "email": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                },
                "role": {
                    "type": "string"
                }
            }
        }
    },
    "securityDefinitions": {
        "BearerAuth": {
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "/",
        Schemes:          []string{},
        Title:            "",
        Description:      "API for AutoRepair Shop Management System",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package http

import (
        "encoding/json"
        "net/http"

        "github.com/go-chi/chi/v5"
        "github.com/noggrj/autorepair/internal/identity/domain"
        "github.com/noggrj/autorepair/internal/platform/auth"
        "github.com/noggrj/autorepair/internal/platform/errors"
)

type AuthHandler struct {
        repo domain.UserRepository
}

func NewAuthHandler(repo domain.UserRepository) *AuthHandler <span class="cov8" title="1">{
        return &amp;AuthHandler{repo: repo}
}</span>

type registerRequest struct {
        Name     string `json:"name"`
        Email    string `json:"email"`
        Password string `json:"password"`
        Role     string `json:"role"`
}

type loginRequest struct {
        Email    string `json:"email"`
        Password string `json:"password"`
}

// Register godoc
// @Summary Register a new user
// @Description Register a new user with name, email, password and role
// @Tags auth
// @Accept json
// @Produce json
// @Param request body registerRequest true "Register Request"
// @Success 201 {object} domain.User
// @Failure 400 {object} errors.ErrorResponse
// @Failure 500 {object} errors.ErrorResponse
// @Router /auth/register [post]
func (h *AuthHandler) Register(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req registerRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                errors.BadRequest(w, "invalid request body")
                return
        }</span>

        <span class="cov8" title="1">user, err := domain.NewUser(req.Name, req.Email, req.Password, domain.Role(req.Role))
        if err != nil </span><span class="cov8" title="1">{
                errors.InternalServerError(w, err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := h.repo.Save(user); err != nil </span><span class="cov8" title="1">{
                errors.InternalServerError(w, "failed to save user")
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusCreated)
        if err := json.NewEncoder(w).Encode(user); err != nil </span><span class="cov8" title="1">{
                errors.InternalServerError(w, "failed to encode response")
                return
        }</span>
}

type loginResponse struct {
        AccessToken  string `json:"access_token"`
        RefreshToken string `json:"refresh_token"`
        ExpiresIn    int64  `json:"expires_in"`
}

// Login godoc
// @Summary Login
// @Description Login with email and password to get a JWT token
// @Tags auth
// @Accept json
// @Produce json
// @Param request body loginRequest true "Login Request"
// @Success 200 {object} loginResponse
// @Failure 401 {object} errors.ErrorResponse
// @Failure 500 {object} errors.ErrorResponse
// @Router /auth/login [post]
func (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req loginRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                errors.BadRequest(w, "invalid request body")
                return
        }</span>

        <span class="cov8" title="1">user, err := h.repo.GetByEmail(req.Email)
        if err != nil </span><span class="cov8" title="1">{
                errors.Unauthorized(w, "invalid credentials")
                return
        }</span>

        <span class="cov8" title="1">if !user.CheckPassword(req.Password) </span><span class="cov8" title="1">{
                errors.Unauthorized(w, "invalid credentials")
                return
        }</span>

        <span class="cov8" title="1">accessToken, refreshToken, expiresIn, err := auth.GenerateToken(user.ID, string(user.Role))
        if err != nil </span><span class="cov0" title="0">{
                errors.InternalServerError(w, "failed to generate token")
                return
        }</span>

        <span class="cov8" title="1">if err := json.NewEncoder(w).Encode(loginResponse{
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
                ExpiresIn:    expiresIn,
        }); err != nil </span><span class="cov8" title="1">{
                errors.InternalServerError(w, "failed to encode response")
                return
        }</span>
}

type refreshTokenRequest struct {
        RefreshToken string `json:"refresh_token"`
}

// Refresh godoc
// @Summary Refresh Access Token
// @Description Use a refresh token to get a new access token
// @Tags auth
// @Accept json
// @Produce json
// @Param request body refreshTokenRequest true "Refresh Token Request"
// @Success 200 {object} loginResponse
// @Failure 401 {object} errors.ErrorResponse
// @Failure 500 {object} errors.ErrorResponse
// @Router /auth/refresh [post]
func (h *AuthHandler) Refresh(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req refreshTokenRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                errors.BadRequest(w, "invalid request body")
                return
        }</span>

        <span class="cov8" title="1">claims, err := auth.ValidateToken(req.RefreshToken)
        if err != nil </span><span class="cov8" title="1">{
                errors.Unauthorized(w, "invalid refresh token")
                return
        }</span>

        // In a real app, we might check if the user is still active or if token is revoked here.

        <span class="cov8" title="1">accessToken, refreshToken, expiresIn, err := auth.GenerateToken(claims.UserID, claims.Role)
        if err != nil </span><span class="cov0" title="0">{
                errors.InternalServerError(w, "failed to generate token")
                return
        }</span>

        <span class="cov8" title="1">if err := json.NewEncoder(w).Encode(loginResponse{
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
                ExpiresIn:    expiresIn,
        }); err != nil </span><span class="cov8" title="1">{
                errors.InternalServerError(w, "failed to encode response")
                return
        }</span>
}

func (h *AuthHandler) RegisterRoutes(r chi.Router) <span class="cov8" title="1">{
        r.Post("/register", h.Register)
        r.Post("/login", h.Login)
        r.Post("/refresh", h.Refresh)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package domain

import (
        "time"

        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"
)

type Role string

const (
        RoleAdmin    Role = "admin"
        RoleManager  Role = "manager"
        RoleEmployee Role = "employee"
)

type User struct {
        ID        uuid.UUID
        Name      string
        Email     string
        Password  string // Hashed
        Role      Role
        CreatedAt time.Time
        UpdatedAt time.Time
}

func NewUser(name, email, password string, role Role) (*User, error) <span class="cov8" title="1">{
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;User{
                ID:        uuid.New(),
                Name:      name,
                Email:     email,
                Password:  string(hashedPassword),
                Role:      role,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }, nil</span>
}

func (u *User) CheckPassword(password string) bool <span class="cov8" title="1">{
        err := bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(password))
        return err == nil
}</span>

type UserRepository interface {
        Save(user *User) error
        GetByEmail(email string) (*User, error)
        GetByID(id uuid.UUID) (*User, error)
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package infrastructure

import (
        "context"
        "errors"

        "github.com/google/uuid"
        "github.com/jackc/pgx/v5"
        "github.com/noggrj/autorepair/internal/identity/domain"
        "github.com/noggrj/autorepair/internal/platform/db"
)

type PostgresUserRepository struct {
        db db.Connection
}

func NewPostgresUserRepository(db db.Connection) *PostgresUserRepository <span class="cov8" title="1">{
        return &amp;PostgresUserRepository{db: db}
}</span>

func (r *PostgresUserRepository) Save(user *domain.User) error <span class="cov8" title="1">{
        query := `INSERT INTO users (id, name, email, password_hash, role, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7)`
        _, err := r.db.Exec(context.Background(), query, user.ID, user.Name, user.Email, user.Password, user.Role, user.CreatedAt, user.UpdatedAt)
        return err
}</span>

func (r *PostgresUserRepository) GetByEmail(email string) (*domain.User, error) <span class="cov8" title="1">{
        query := `SELECT id, name, email, password_hash, role, created_at, updated_at FROM users WHERE email = $1`
        row := r.db.QueryRow(context.Background(), query, email)

        var user domain.User
        var role string
        err := row.Scan(&amp;user.ID, &amp;user.Name, &amp;user.Email, &amp;user.Password, &amp;role, &amp;user.CreatedAt, &amp;user.UpdatedAt)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov8" title="1">{
                        return nil, errors.New("user not found")
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }
        <span class="cov8" title="1">user.Role = domain.Role(role)
        return &amp;user, nil</span>
}

func (r *PostgresUserRepository) GetByID(id uuid.UUID) (*domain.User, error) <span class="cov8" title="1">{
        query := `SELECT id, name, email, password_hash, role, created_at, updated_at FROM users WHERE id = $1`
        row := r.db.QueryRow(context.Background(), query, id)

        var user domain.User
        var role string
        err := row.Scan(&amp;user.ID, &amp;user.Name, &amp;user.Email, &amp;user.Password, &amp;role, &amp;user.CreatedAt, &amp;user.UpdatedAt)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov8" title="1">{
                        return nil, errors.New("user not found")
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }
        <span class="cov8" title="1">user.Role = domain.Role(role)
        return &amp;user, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package domain

import (
        "errors"

        "github.com/google/uuid"
)

var ErrInsufficientStock = errors.New("insufficient stock")

type Part struct {
        ID          uuid.UUID
        Name        string
        Description string
        Quantity    int
        Price       float64
}

func NewPart(name, description string, quantity int, price float64) (*Part, error) <span class="cov8" title="1">{
        if quantity &lt; 0 </span><span class="cov8" title="1">{
                return nil, errors.New("quantity cannot be negative")
        }</span>
        <span class="cov8" title="1">if price &lt; 0 </span><span class="cov8" title="1">{
                return nil, errors.New("price cannot be negative")
        }</span>

        <span class="cov8" title="1">return &amp;Part{
                ID:          uuid.New(),
                Name:        name,
                Description: description,
                Quantity:    quantity,
                Price:       price,
        }, nil</span>
}

func (p *Part) RemoveStock(qty int) error <span class="cov8" title="1">{
        if p.Quantity &lt; qty </span><span class="cov8" title="1">{
                return ErrInsufficientStock
        }</span>
        <span class="cov8" title="1">p.Quantity -= qty
        return nil</span>
}

func (p *Part) AddStock(qty int) <span class="cov0" title="0">{
        p.Quantity += qty
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package infrastructure

import (
        "context"
        "errors"

        "github.com/google/uuid"
        "github.com/jackc/pgx/v5"
        "github.com/noggrj/autorepair/internal/inventory/domain"
        "github.com/noggrj/autorepair/internal/platform/db"
)

type PostgresPartRepository struct {
        db db.Connection
}

func NewPostgresPartRepository(db db.Connection) *PostgresPartRepository <span class="cov8" title="1">{
        return &amp;PostgresPartRepository{db: db}
}</span>

func (r *PostgresPartRepository) Save(ctx context.Context, part *domain.Part) error <span class="cov8" title="1">{
        query := `INSERT INTO parts (id, name, description, stock_qty, price) VALUES ($1, $2, $3, $4, $5)`
        _, err := r.db.Exec(ctx, query, part.ID, part.Name, part.Description, part.Quantity, part.Price)
        return err
}</span>

func (r *PostgresPartRepository) GetByID(ctx context.Context, id uuid.UUID) (*domain.Part, error) <span class="cov8" title="1">{
        query := `SELECT id, name, description, stock_qty, price FROM parts WHERE id = $1`
        row := r.db.QueryRow(ctx, query, id)

        var part domain.Part
        err := row.Scan(&amp;part.ID, &amp;part.Name, &amp;part.Description, &amp;part.Quantity, &amp;part.Price)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov8" title="1">{
                        return nil, errors.New("part not found")
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;part, nil</span>
}

func (r *PostgresPartRepository) Update(ctx context.Context, part *domain.Part) error <span class="cov8" title="1">{
        query := `UPDATE parts SET name = $1, description = $2, stock_qty = $3, price = $4 WHERE id = $5`
        _, err := r.db.Exec(ctx, query, part.Name, part.Description, part.Quantity, part.Price, part.ID)
        return err
}</span>

func (r *PostgresPartRepository) List(ctx context.Context) ([]*domain.Part, error) <span class="cov8" title="1">{
        query := `SELECT id, name, description, stock_qty, price FROM parts`
        rows, err := r.db.Query(ctx, query)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var parts []*domain.Part
        for rows.Next() </span><span class="cov8" title="1">{
                var p domain.Part
                if err := rows.Scan(&amp;p.ID, &amp;p.Name, &amp;p.Description, &amp;p.Quantity, &amp;p.Price); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">parts = append(parts, &amp;p)</span>
        }
        <span class="cov8" title="1">return parts, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package infrastructure

import (
        "log"
)

type ConsoleEmailService struct{}

func NewConsoleEmailService() *ConsoleEmailService <span class="cov8" title="1">{
        return &amp;ConsoleEmailService{}
}</span>

func (s *ConsoleEmailService) SendEmail(to, subject, body string) error <span class="cov8" title="1">{
        log.Printf("================ EMAIL NOTIFICATION ================")
        log.Printf("To: %s", to)
        log.Printf("Subject: %s", subject)
        log.Printf("Body: %s", body)
        log.Printf("====================================================")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package infrastructure

import "github.com/stretchr/testify/mock"

type MockEmailService struct {
        mock.Mock
}

func (m *MockEmailService) SendEmail(to, subject, body string) error <span class="cov0" title="0">{
        args := m.Called(to, subject, body)
        return args.Error(0)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package auth

import (
        "errors"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
)

var secretKey = []byte("secret")

type Claims struct {
        UserID uuid.UUID `json:"user_id"`
        Role   string    `json:"role"`
        jwt.RegisteredClaims
}

func GenerateToken(userID uuid.UUID, role string) (string, string, int64, error) <span class="cov8" title="1">{
        expirationTime := time.Now().Add(15 * time.Minute)
        claims := &amp;Claims{
                UserID: userID,
                Role:   role,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(expirationTime),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        accessToken, err := token.SignedString(secretKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", 0, err
        }</span>

        <span class="cov8" title="1">refreshClaims := &amp;Claims{
                UserID: userID,
                Role:   role,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(7 * 24 * time.Hour)),
                },
        }
        refreshToken := jwt.NewWithClaims(jwt.SigningMethodHS256, refreshClaims)
        refreshTokenString, err := refreshToken.SignedString(secretKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", 0, err
        }</span>

        <span class="cov8" title="1">return accessToken, refreshTokenString, int64(time.Until(expirationTime).Seconds()), nil</span>
}

func ValidateToken(tokenString string) (*Claims, error) <span class="cov8" title="1">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                return secretKey, nil
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if claims, ok := token.Claims.(*Claims); ok &amp;&amp; token.Valid </span><span class="cov8" title="1">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, errors.New("invalid token")</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package config

import (
        "fmt"
        "os"
)

type Config struct {
        DBURL string
        Port  string
}

func Load() (*Config, error) <span class="cov8" title="1">{
        dbURL := os.Getenv("DB_URL")
        if dbURL == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("DB_URL is required")
        }</span>

        <span class="cov8" title="1">port := os.Getenv("PORT")
        if port == "" </span><span class="cov8" title="1">{
                port = "8080"
        }</span>

        <span class="cov8" title="1">return &amp;Config{
                DBURL: dbURL,
                Port:  port,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package db

import (
        "context"
        "fmt"
        "time"

        "github.com/jackc/pgx/v5/pgxpool"
)

type DB struct {
        Pool *pgxpool.Pool
}

func New(url string) (*DB, error) <span class="cov0" title="0">{
        config, err := pgxpool.ParseConfig(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config: %w", err)
        }</span>

        <span class="cov0" title="0">config.MaxConns = 10
        config.MinConns = 2
        config.MaxConnLifetime = time.Hour
        config.MaxConnIdleTime = 30 * time.Minute

        pool, err := pgxpool.NewWithConfig(context.Background(), config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to db: %w", err)
        }</span>

        <span class="cov0" title="0">if err := pool.Ping(context.Background()); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping db: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;DB{Pool: pool}, nil</span>
}

func (db *DB) Close() <span class="cov0" title="0">{
        db.Pool.Close()
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package errors

import (
        "encoding/json"
        "net/http"
)

type ErrorResponse struct {
        Message string `json:"message"`
}

func JSON(w http.ResponseWriter, status int, message string) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        if err := json.NewEncoder(w).Encode(ErrorResponse{Message: message}); err != nil </span><span class="cov8" title="1">{
                // Log encoding error but cannot change response at this point
                _ = err // ignore error
        }</span>
}

func BadRequest(w http.ResponseWriter, message string) <span class="cov8" title="1">{
        JSON(w, http.StatusBadRequest, message)
}</span>

func Unauthorized(w http.ResponseWriter, message string) <span class="cov8" title="1">{
        JSON(w, http.StatusUnauthorized, message)
}</span>

func Forbidden(w http.ResponseWriter, message string) <span class="cov8" title="1">{
        JSON(w, http.StatusForbidden, message)
}</span>

func NotFound(w http.ResponseWriter, message string) <span class="cov8" title="1">{
        JSON(w, http.StatusNotFound, message)
}</span>

func InternalServerError(w http.ResponseWriter, message string) <span class="cov8" title="1">{
        JSON(w, http.StatusInternalServerError, message)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package middleware

import (
        "context"
        "net/http"
        "strings"

        "github.com/noggrj/autorepair/internal/platform/auth"
        "github.com/noggrj/autorepair/internal/platform/errors"
)

type contextKey string

const UserContextKey contextKey = "user"

func AuthMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                authHeader := r.Header.Get("Authorization")
                if authHeader == "" </span><span class="cov8" title="1">{
                        errors.Unauthorized(w, "missing authorization header")
                        return
                }</span>

                <span class="cov8" title="1">parts := strings.Split(authHeader, " ")
                if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov8" title="1">{
                        errors.Unauthorized(w, "invalid authorization header format")
                        return
                }</span>

                <span class="cov8" title="1">claims, err := auth.ValidateToken(parts[1])
                if err != nil </span><span class="cov8" title="1">{
                        errors.Unauthorized(w, "invalid token")
                        return
                }</span>

                <span class="cov8" title="1">ctx := context.WithValue(r.Context(), UserContextKey, claims)
                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}

func RoleMiddleware(role string) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        claims, ok := r.Context().Value(UserContextKey).(*auth.Claims)
                        if !ok </span><span class="cov8" title="1">{
                                errors.Unauthorized(w, "user not authenticated")
                                return
                        }</span>

                        <span class="cov8" title="1">if claims.Role != role &amp;&amp; claims.Role != "admin" </span><span class="cov8" title="1">{ // Admin can access everything
                                errors.Forbidden(w, "insufficient permissions")
                                return
                        }</span>

                        <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package application

import (
        "errors"
        "fmt"
        "time"

        "context"

        "github.com/google/uuid"
        inventoryDomain "github.com/noggrj/autorepair/internal/inventory/domain"
        notificationDomain "github.com/noggrj/autorepair/internal/notification/domain"
        serviceDomain "github.com/noggrj/autorepair/internal/service/domain"
)

type OrderService struct {
        orderRepo  serviceDomain.OrderRepository
        partRepo   inventoryDomain.PartRepository
        clientRepo serviceDomain.ClientRepository
        notifier   notificationDomain.EmailService
}

func NewOrderService(
        orderRepo serviceDomain.OrderRepository,
        partRepo inventoryDomain.PartRepository,
        clientRepo serviceDomain.ClientRepository,
        notifier notificationDomain.EmailService,
) *OrderService <span class="cov8" title="1">{
        return &amp;OrderService{
                orderRepo:  orderRepo,
                partRepo:   partRepo,
                clientRepo: clientRepo,
                notifier:   notifier,
        }
}</span>

func (s *OrderService) StartDiagnosis(orderID uuid.UUID) error <span class="cov8" title="1">{
        order, err := s.orderRepo.GetByID(orderID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if order.Status != serviceDomain.OrderStatusReceived </span><span class="cov8" title="1">{
                return errors.New("diagnosis can only be started from 'Received' status")
        }</span>

        <span class="cov8" title="1">order.Status = serviceDomain.OrderStatusInDiagnosis
        if err := s.orderRepo.Save(order); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">s.notifyStatusChange(order)
        return nil</span>
}

func (s *OrderService) SendBudget(orderID uuid.UUID) error <span class="cov8" title="1">{
        order, err := s.orderRepo.GetByID(orderID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if order.Status != serviceDomain.OrderStatusInDiagnosis </span><span class="cov8" title="1">{
                return errors.New("budget can only be sent from 'In diagnosis' status")
        }</span>

        <span class="cov8" title="1">order.Status = serviceDomain.OrderStatusAwaitingApproval
        if err := s.orderRepo.Save(order); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Notify specifically about budget
        <span class="cov8" title="1">client, err := s.clientRepo.GetByID(order.ClientID)
        if err != nil </span><span class="cov8" title="1">{
                // Log error but continue with order status update
                return nil
        }</span>
        <span class="cov8" title="1">if err := s.notifier.SendEmail(client.Email, "Order Budget Ready", fmt.Sprintf("Your budget for order %s is ready. Total: %.2f", order.ID, order.Total)); err != nil </span><span class="cov8" title="1">{
                // Log error but continue with order status update
                _ = err // ignore error
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *OrderService) ApproveOrder(orderID uuid.UUID) error <span class="cov8" title="1">{
        // 1. Get Order
        order, err := s.orderRepo.GetByID(orderID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // 2. Validate Status
        // Allow approval from Received (direct) or Awaiting Approval (flow)
        <span class="cov8" title="1">if order.Status != serviceDomain.OrderStatusReceived &amp;&amp; order.Status != serviceDomain.OrderStatusAwaitingApproval </span><span class="cov8" title="1">{
                return errors.New("order can only be approved from 'Received' or 'Awaiting approval' status")
        }</span>

        // 3. Process Parts (Decrease Stock)
        <span class="cov8" title="1">for _, item := range order.Items </span><span class="cov8" title="1">{
                if item.Type == serviceDomain.ItemTypePart </span><span class="cov8" title="1">{
                        // Get Part to check stock and decrease it
                        part, err := s.partRepo.GetByID(context.Background(), item.RefID)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if err := part.RemoveStock(item.Quantity); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if err := s.partRepo.Update(context.Background(), part); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
        }

        // 4. Update Status
        <span class="cov8" title="1">order.Status = serviceDomain.OrderStatusInExecution
        now := time.Now()
        order.StartedAt = &amp;now

        // 5. Save
        if err := s.orderRepo.Save(order); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // 6. Notify
        <span class="cov8" title="1">s.notifyStatusChange(order)

        return nil</span>
}

func (s *OrderService) FinishOrder(orderID uuid.UUID) error <span class="cov8" title="1">{
        order, err := s.orderRepo.GetByID(orderID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if order.Status != serviceDomain.OrderStatusInExecution </span><span class="cov8" title="1">{
                return errors.New("order can only be finished from 'In execution' status")
        }</span>

        <span class="cov8" title="1">order.Status = serviceDomain.OrderStatusCompleted // "Finished" in requirements
        now := time.Now()
        order.FinishedAt = &amp;now

        if err := s.orderRepo.Save(order); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">s.notifyStatusChange(order)
        return nil</span>
}

func (s *OrderService) DeliverOrder(orderID uuid.UUID) error <span class="cov8" title="1">{
        order, err := s.orderRepo.GetByID(orderID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if order.Status != serviceDomain.OrderStatusCompleted </span><span class="cov8" title="1">{
                return errors.New("order can only be delivered from 'Completed' status")
        }</span>

        <span class="cov8" title="1">order.Status = serviceDomain.OrderStatusDelivered
        if err := s.orderRepo.Save(order); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">s.notifyStatusChange(order)
        return nil</span>
}

func (s *OrderService) UpdateStatus(orderID uuid.UUID, status serviceDomain.OrderStatus) error <span class="cov8" title="1">{
        order, err := s.orderRepo.GetByID(orderID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">order.Status = status
        if err := s.orderRepo.Save(order); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">s.notifyStatusChange(order)

        return nil</span>
}

func (s *OrderService) notifyStatusChange(order *serviceDomain.Order) <span class="cov8" title="1">{
        client, err := s.clientRepo.GetByID(order.ClientID)
        if err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail flow
                return
        }</span>

        <span class="cov8" title="1">subject := fmt.Sprintf("Order Update: %s", order.Status)
        body := fmt.Sprintf("Hello %s, your order %s status has been updated to: %s", client.Name, order.ID, order.Status)

        if err := s.notifier.SendEmail(client.Email, subject, body); err != nil </span><span class="cov0" title="0">{
                // Log error but continue
                _ = err // ignore error
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package http

import (
        "encoding/json"
        "net/http"

        "github.com/noggrj/autorepair/internal/service/domain"
)

type ClientHandler struct {
        repo domain.ClientRepository
}

func NewClientHandler(repo domain.ClientRepository) *ClientHandler <span class="cov8" title="1">{
        return &amp;ClientHandler{repo: repo}
}</span>

type CreateClientRequest struct {
        Name     string `json:"name"`
        Document string `json:"document"`
        Email    string `json:"email"`
        Phone    string `json:"phone"`
}

// @Summary Create Client
// @Description Register a new client
// @Tags clients
// @Accept json
// @Produce json
// @Param client body CreateClientRequest true "Client Details"
// @Success 201 {object} map[string]interface{}
// @Failure 400 {object} string "Invalid input"
// @Failure 500 {object} string "Internal Server Error"
// @Router /admin/clients [post]
func (h *ClientHandler) Create(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req CreateClientRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">client, err := domain.NewClient(req.Name, req.Document, req.Email, req.Phone)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if err := h.repo.Save(client); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to save client", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusCreated)
        if err := json.NewEncoder(w).Encode(client); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to encode response", http.StatusInternalServerError)
                return
        }</span>
}

// @Summary List Clients
// @Description List all clients
// @Tags clients
// @Accept json
// @Produce json
// @Success 200 {array} map[string]interface{}
// @Failure 500 {object} string "Internal Server Error"
// @Router /admin/clients [get]
func (h *ClientHandler) List(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        clients, err := h.repo.List()
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Failed to list clients", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(clients); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to encode response", http.StatusInternalServerError)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package http

import (
        "encoding/json"
        "net/http"
        "time"

        "github.com/go-chi/chi/v5"
        "github.com/google/uuid"
        inventoryDomain "github.com/noggrj/autorepair/internal/inventory/domain"
        serviceApplication "github.com/noggrj/autorepair/internal/service/application"
        serviceDomain "github.com/noggrj/autorepair/internal/service/domain"
)

type PartHandler struct {
        repo inventoryDomain.PartRepository
}

func NewPartHandler(repo inventoryDomain.PartRepository) *PartHandler <span class="cov8" title="1">{
        return &amp;PartHandler{repo: repo}
}</span>

type CreatePartRequest struct {
        Name        string  `json:"name"`
        Description string  `json:"description"`
        Price       float64 `json:"price"`
        StockQty    int     `json:"stock_qty"`
}

// @Summary Create Part
// @Description Register a new part
// @Tags parts
// @Accept json
// @Produce json
// @Param part body CreatePartRequest true "Part Details"
// @Success 201 {object} map[string]interface{}
// @Failure 400 {object} string "Invalid input"
// @Failure 500 {object} string "Internal Server Error"
// @Router /admin/parts [post]
func (h *PartHandler) Create(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req CreatePartRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">part, err := inventoryDomain.NewPart(req.Name, req.Description, req.StockQty, req.Price)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if err := h.repo.Save(r.Context(), part); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to save part", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusCreated)
        if err := json.NewEncoder(w).Encode(part); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to encode response", http.StatusInternalServerError)
                return
        }</span>
}

// @Summary List Parts
// @Description List all parts
// @Tags parts
// @Accept json
// @Produce json
// @Success 200 {array} map[string]interface{}
// @Failure 500 {object} string "Internal Server Error"
// @Router /admin/parts [get]
func (h *PartHandler) List(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        parts, err := h.repo.List(r.Context())
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Failed to list parts", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(parts); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to encode response", http.StatusInternalServerError)
                return
        }</span>
}

// ---------------------------------------------------------

type ServiceHandler struct {
        repo serviceDomain.ServiceRepository
}

func NewServiceHandler(repo serviceDomain.ServiceRepository) *ServiceHandler <span class="cov8" title="1">{
        return &amp;ServiceHandler{repo: repo}
}</span>

type CreateServiceRequest struct {
        Name        string  `json:"name"`
        Description string  `json:"description"`
        Price       float64 `json:"price"`
}

// @Summary Create Service
// @Description Register a new service (labor)
// @Tags services
// @Accept json
// @Produce json
// @Param service body CreateServiceRequest true "Service Details"
// @Success 201 {object} map[string]interface{}
// @Failure 400 {object} string "Invalid input"
// @Failure 500 {object} string "Internal Server Error"
// @Router /admin/services [post]
func (h *ServiceHandler) Create(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req CreateServiceRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">service, err := serviceDomain.NewService(req.Name, req.Description, req.Price)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if err := h.repo.Save(service); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to save service", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusCreated)
        if err := json.NewEncoder(w).Encode(service); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to encode response", http.StatusInternalServerError)
                return
        }</span>
}

// @Summary List Services
// @Description List all services
// @Tags services
// @Accept json
// @Produce json
// @Success 200 {array} map[string]interface{}
// @Failure 500 {object} string "Internal Server Error"
// @Router /admin/services [get]
func (h *ServiceHandler) List(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        services, err := h.repo.List()
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Failed to list services", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(services); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to encode response", http.StatusInternalServerError)
                return
        }</span>
}

// ---------------------------------------------------------

type OrderHandler struct {
        orderRepo    serviceDomain.OrderRepository
        partRepo     inventoryDomain.PartRepository
        serviceRepo  serviceDomain.ServiceRepository
        orderService *serviceApplication.OrderService
}

func NewOrderHandler(
        orderRepo serviceDomain.OrderRepository,
        partRepo inventoryDomain.PartRepository,
        serviceRepo serviceDomain.ServiceRepository,
        orderService *serviceApplication.OrderService,
) *OrderHandler <span class="cov8" title="1">{
        return &amp;OrderHandler{
                orderRepo:    orderRepo,
                partRepo:     partRepo,
                serviceRepo:  serviceRepo,
                orderService: orderService,
        }
}</span>

// ... (Create method remains unchanged)

// @Summary Approve Order
// @Description Approve an order and reserve parts
// @Tags orders
// @Accept json
// @Produce json
// @Param id path string true "Order ID"
// @Success 200
// @Failure 400 {object} string "Invalid order ID"
// @Failure 409 {object} string "Insufficient stock"
// @Failure 500 {object} string "Internal Server Error"
// @Router /admin/orders/{id}/approve [patch]
func (h *OrderHandler) Approve(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        idStr := chi.URLParam(r, "id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid order ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if err := h.orderService.ApproveOrder(id); err != nil </span><span class="cov8" title="1">{
                if err == inventoryDomain.ErrInsufficientStock </span><span class="cov8" title="1">{
                        http.Error(w, err.Error(), http.StatusConflict)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, err.Error(), http.StatusInternalServerError)
                return</span>
        }

        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)</span>
}

// @Summary Start Diagnosis
// @Description Start the diagnosis process for an order
// @Tags orders
// @Accept json
// @Produce json
// @Param id path string true "Order ID"
// @Success 200
// @Failure 400 {object} string "Invalid order ID"
// @Failure 500 {object} string "Internal Server Error"
// @Router /admin/orders/{id}/diagnosis:start [post]
func (h *OrderHandler) StartDiagnosis(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        idStr := chi.URLParam(r, "id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid order ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if err := h.orderService.StartDiagnosis(id); err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)</span>
}

// @Summary Send Budget
// @Description Send budget to the client for approval
// @Tags orders
// @Accept json
// @Produce json
// @Param id path string true "Order ID"
// @Success 200
// @Failure 400 {object} string "Invalid order ID"
// @Failure 500 {object} string "Internal Server Error"
// @Router /admin/orders/{id}/budget:send [post]
func (h *OrderHandler) SendBudget(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        idStr := chi.URLParam(r, "id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid order ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if err := h.orderService.SendBudget(id); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)</span>
}

// @Summary Finish Order
// @Description Mark order as finished (Completed)
// @Tags orders
// @Accept json
// @Produce json
// @Param id path string true "Order ID"
// @Success 200
// @Failure 400 {object} string "Invalid order ID"
// @Failure 500 {object} string "Internal Server Error"
// @Router /admin/orders/{id}/finish [post]
func (h *OrderHandler) FinishOrder(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        idStr := chi.URLParam(r, "id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid order ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if err := h.orderService.FinishOrder(id); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)</span>
}

// @Summary Deliver Order
// @Description Mark order as delivered to client
// @Tags orders
// @Accept json
// @Produce json
// @Param id path string true "Order ID"
// @Success 200
// @Failure 400 {object} string "Invalid order ID"
// @Failure 500 {object} string "Internal Server Error"
// @Router /admin/orders/{id}/deliver [post]
func (h *OrderHandler) DeliverOrder(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        idStr := chi.URLParam(r, "id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid order ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if err := h.orderService.DeliverOrder(id); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)</span>
}

type UpdateStatusRequest struct {
        Status string `json:"status"`
}

// @Summary Update Order Status
// @Description Update status of an order
// @Tags orders
// @Accept json
// @Produce json
// @Param id path string true "Order ID"
// @Param status body UpdateStatusRequest true "New Status"
// @Success 200
// @Failure 400 {object} string "Invalid input"
// @Failure 500 {object} string "Internal Server Error"
// @Router /admin/orders/{id}/status [patch]
func (h *OrderHandler) UpdateStatus(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        idStr := chi.URLParam(r, "id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid order ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">var req UpdateStatusRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">status := serviceDomain.OrderStatus(req.Status)
        // Ideally validate status enum here

        if err := h.orderService.UpdateStatus(id, status); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)</span>
}

type CreateOrderItemRequest struct {
        Type     string `json:"type"` // "service" or "part"
        RefID    string `json:"ref_id"`
        Quantity int    `json:"quantity"`
}

type CreateOrderRequest struct {
        ClientID  string                   `json:"client_id"`
        VehicleID string                   `json:"vehicle_id"`
        Items     []CreateOrderItemRequest `json:"items"`
}

// @Summary Create Order
// @Description Create a new service order
// @Tags orders
// @Accept json
// @Produce json
// @Param order body CreateOrderRequest true "Order Request"
// @Success 201 {object} map[string]interface{}
// @Failure 400 {object} string "Invalid input"
// @Failure 500 {object} string "Internal Server Error"
// @Router /admin/orders [post]
func (h *OrderHandler) Create(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req CreateOrderRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">clientID, err := uuid.Parse(req.ClientID)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid client ID", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">vehicleID, err := uuid.Parse(req.VehicleID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid vehicle ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">order, err := serviceDomain.NewOrder(clientID, vehicleID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">for _, itemReq := range req.Items </span><span class="cov8" title="1">{
                refID, err := uuid.Parse(itemReq.RefID)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Invalid item ref ID", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">switch serviceDomain.OrderItemType(itemReq.Type) </span>{
                case serviceDomain.ItemTypeService:<span class="cov8" title="1">
                        svc, err := h.serviceRepo.GetByID(refID)
                        if err != nil </span><span class="cov8" title="1">{
                                http.Error(w, "Service not found: "+refID.String(), http.StatusBadRequest)
                                return
                        }</span>
                        <span class="cov8" title="1">err = order.AddItem(refID, serviceDomain.ItemTypeService, svc.Name, itemReq.Quantity, float64(svc.Price))
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, err.Error(), http.StatusBadRequest)
                                return
                        }</span>
                case serviceDomain.ItemTypePart:<span class="cov8" title="1">
                        part, err := h.partRepo.GetByID(r.Context(), refID)
                        if err != nil </span><span class="cov8" title="1">{
                                http.Error(w, "Part not found: "+refID.String(), http.StatusBadRequest)
                                return
                        }</span>
                        // Note: We check stock here but decrement only on approval (Sprint 3)
                        // Requirements: "Automatically generate estimate/budget"
                        <span class="cov8" title="1">err = order.AddItem(refID, serviceDomain.ItemTypePart, part.Name, itemReq.Quantity, float64(part.Price))
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, err.Error(), http.StatusBadRequest)
                                return
                        }</span>
                default:<span class="cov0" title="0">
                        http.Error(w, "Invalid item type", http.StatusBadRequest)
                        return</span>
                }
        }

        <span class="cov8" title="1">if err := h.orderRepo.Save(order); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Failed to save order", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusCreated)
        if err := json.NewEncoder(w).Encode(order); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to encode response", http.StatusInternalServerError)
                return
        }</span>
}

// @Summary Get Order
// @Description Get details of a specific order
// @Tags orders
// @Accept json
// @Produce json
// @Param id path string true "Order ID"
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} string "Invalid order ID"
// @Failure 404 {object} string "Order not found"
// @Failure 500 {object} string "Internal Server Error"
// @Router /admin/orders/{id} [get]
func (h *OrderHandler) Get(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        idStr := chi.URLParam(r, "id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid order ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">order, err := h.orderRepo.GetByID(id)
        if err != nil </span><span class="cov8" title="1">{
                if err == serviceDomain.ErrOrderNotFound </span><span class="cov8" title="1">{
                        http.Error(w, "Order not found", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, err.Error(), http.StatusInternalServerError)
                return</span>
        }

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(order); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to encode response", http.StatusInternalServerError)
                return
        }</span>
}

// @Summary Report Revenue
// @Description Get total revenue report
// @Tags reports
// @Accept json
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 500 {object} string "Internal Server Error"
// @Router /admin/reports/revenue [get]
func (h *OrderHandler) ReportRevenue(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        orders, err := h.orderRepo.List()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to list orders", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">var totalRevenue float64
        for _, o := range orders </span><span class="cov8" title="1">{
                totalRevenue += float64(o.Total)
        }</span>

        <span class="cov8" title="1">response := map[string]interface{}{
                "period":        "all_time",
                "total_revenue": totalRevenue,
                "order_count":   len(orders),
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to encode response", http.StatusInternalServerError)
                return
        }</span>
}

// @Summary Report Avg Execution Time
// @Description Get average execution time of orders (In Execution -&gt; Completed)
// @Tags reports
// @Accept json
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 500 {object} string "Internal Server Error"
// @Router /admin/reports/avg-execution-time [get]
func (h *OrderHandler) ReportAvgExecutionTime(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        orders, err := h.orderRepo.List()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to list orders", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">var totalDuration time.Duration
        var count int

        for _, o := range orders </span><span class="cov8" title="1">{
                if o.Status == serviceDomain.OrderStatusCompleted || o.Status == serviceDomain.OrderStatusDelivered </span><span class="cov8" title="1">{
                        if o.StartedAt != nil &amp;&amp; o.FinishedAt != nil </span><span class="cov8" title="1">{
                                totalDuration += o.FinishedAt.Sub(*o.StartedAt)
                                count++
                        }</span>
                }
        }

        <span class="cov8" title="1">var avgMinutes float64
        if count &gt; 0 </span><span class="cov8" title="1">{
                avgMinutes = totalDuration.Minutes() / float64(count)
        }</span>

        <span class="cov8" title="1">response := map[string]interface{}{
                "avg_execution_minutes": avgMinutes,
                "orders_counted":        count,
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to encode response", http.StatusInternalServerError)
                return
        }</span>
}

type OrderTrackingItem struct {
        Name     string  `json:"name"`
        Quantity int     `json:"quantity"`
        Total    float64 `json:"total"`
}

type OrderTrackingResponse struct {
        ID        string              `json:"id"`
        Status    string              `json:"status"`
        Total     float64             `json:"total"`
        CreatedAt time.Time           `json:"created_at"`
        Items     []OrderTrackingItem `json:"items"`
}

// @Summary Track Order
// @Description Track the status of an order (Public)
// @Tags public
// @Accept json
// @Produce json
// @Param id path string true "Order ID"
// @Success 200 {object} OrderTrackingResponse
// @Failure 400 {object} string "Invalid order ID"
// @Failure 404 {object} string "Order not found"
// @Failure 500 {object} string "Internal Server Error"
// @Router /orders/{id}/track [get]
func (h *OrderHandler) TrackOrder(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        idStr := chi.URLParam(r, "id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid order ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">order, err := h.orderRepo.GetByID(id)
        if err != nil </span><span class="cov8" title="1">{
                if err == serviceDomain.ErrOrderNotFound </span><span class="cov8" title="1">{
                        http.Error(w, "Order not found", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, err.Error(), http.StatusInternalServerError)
                return</span>
        }

        <span class="cov8" title="1">var items []OrderTrackingItem
        for _, item := range order.Items </span><span class="cov8" title="1">{
                items = append(items, OrderTrackingItem{
                        Name:     item.Name,
                        Quantity: item.Quantity,
                        Total:    float64(item.Total),
                })
        }</span>

        <span class="cov8" title="1">response := OrderTrackingResponse{
                ID:        order.ID.String(),
                Status:    string(order.Status),
                Total:     float64(order.Total),
                CreatedAt: order.CreatedAt,
                Items:     items,
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to encode response", http.StatusInternalServerError)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package http

import (
        "encoding/json"
        "net/http"

        "github.com/google/uuid"
        "github.com/noggrj/autorepair/internal/service/domain"
)

type VehicleHandler struct {
        repo domain.VehicleRepository
}

func NewVehicleHandler(repo domain.VehicleRepository) *VehicleHandler <span class="cov8" title="1">{
        return &amp;VehicleHandler{repo: repo}
}</span>

type CreateVehicleRequest struct {
        ClientID string `json:"client_id"`
        Plate    string `json:"plate"`
        Brand    string `json:"brand"`
        Model    string `json:"model"`
        Year     int    `json:"year"`
}

// @Summary Create Vehicle
// @Description Register a new vehicle
// @Tags vehicles
// @Accept json
// @Produce json
// @Param vehicle body CreateVehicleRequest true "Vehicle Details"
// @Success 201 {object} map[string]interface{}
// @Failure 400 {object} string "Invalid input"
// @Failure 500 {object} string "Internal Server Error"
// @Router /admin/vehicles [post]
func (h *VehicleHandler) Create(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req CreateVehicleRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">clientID, err := uuid.Parse(req.ClientID)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid client ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">vehicle, err := domain.NewVehicle(clientID, req.Plate, req.Brand, req.Model, req.Year)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if err := h.repo.Save(vehicle); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Failed to save vehicle", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusCreated)
        if err := json.NewEncoder(w).Encode(vehicle); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to encode response", http.StatusInternalServerError)
                return
        }</span>
}

// @Summary List Vehicles
// @Description List vehicles by client
// @Tags vehicles
// @Accept json
// @Produce json
// @Param client_id query string true "Client ID"
// @Success 200 {array} map[string]interface{}
// @Failure 400 {object} string "Invalid client ID"
// @Failure 500 {object} string "Internal Server Error"
// @Router /admin/vehicles [get]
func (h *VehicleHandler) ListByClient(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        clientIDStr := r.URL.Query().Get("client_id")
        if clientIDStr == "" </span><span class="cov0" title="0">{
                http.Error(w, "client_id is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">clientID, err := uuid.Parse(clientIDStr)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid client ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">vehicles, err := h.repo.ListByClientID(clientID)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Failed to list vehicles", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(vehicles); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to encode response", http.StatusInternalServerError)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package domain

import (
        "errors"
        "time"

        "github.com/noggrj/autorepair/internal/sharedkernel"
        "github.com/google/uuid"
)

var (
        ErrClientNotFound = errors.New("client not found")
)

type Client struct {
        ID        uuid.UUID
        Name      string
        Document  sharedkernel.DocumentoBR
        Email     string
        Phone     string
        CreatedAt time.Time
        UpdatedAt time.Time
}

func NewClient(name, doc, email, phone string) (*Client, error) <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                return nil, errors.New("name is required")
        }</span>

        <span class="cov8" title="1">d, err := sharedkernel.NewDocumentoBR(doc)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;Client{
                ID:        uuid.New(),
                Name:      name,
                Document:  d,
                Email:     email,
                Phone:     phone,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }, nil</span>
}

// ClientRepository interface is moved to repository.go
</pre>
		
		<pre class="file" id="file19" style="display: none">package domain

import (
        "errors"
        "time"

        "github.com/noggrj/autorepair/internal/sharedkernel"
        "github.com/google/uuid"
)

var (
        ErrOrderNotFound = errors.New("order not found")
)

type OrderItemType string

const (
        ItemTypeService OrderItemType = "service"
        ItemTypePart    OrderItemType = "part"
)

type OrderItem struct {
        ID        uuid.UUID
        OrderID   uuid.UUID
        RefID     uuid.UUID // ID of the Service or Part
        Type      OrderItemType
        Name      string
        Quantity  int
        UnitPrice sharedkernel.Money
        Total     sharedkernel.Money
}

type Order struct {
        ID           uuid.UUID
        ClientID     uuid.UUID
        VehicleID    uuid.UUID
        Status       OrderStatus
        Items        []*OrderItem
        TotalService sharedkernel.Money
        TotalParts   sharedkernel.Money
        Total        sharedkernel.Money
        CreatedAt    time.Time
        UpdatedAt    time.Time
        StartedAt    *time.Time
        FinishedAt   *time.Time
}

func NewOrder(clientID, vehicleID uuid.UUID) (*Order, error) <span class="cov8" title="1">{
        if clientID == uuid.Nil || vehicleID == uuid.Nil </span><span class="cov8" title="1">{
                return nil, errors.New("client and vehicle are required")
        }</span>

        <span class="cov8" title="1">return &amp;Order{
                ID:        uuid.New(),
                ClientID:  clientID,
                VehicleID: vehicleID,
                Status:    OrderStatusReceived,
                Items:     []*OrderItem{},
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }, nil</span>
}

func (o *Order) AddItem(refID uuid.UUID, itemType OrderItemType, name string, qty int, price float64) error <span class="cov8" title="1">{
        if qty &lt;= 0 </span><span class="cov8" title="1">{
                return errors.New("quantity must be positive")
        }</span>
        <span class="cov8" title="1">if price &lt; 0 </span><span class="cov8" title="1">{
                return errors.New("price cannot be negative")
        }</span>

        <span class="cov8" title="1">unitPrice := sharedkernel.Money(price)
        total := sharedkernel.Money(float64(qty) * price)

        item := &amp;OrderItem{
                ID:        uuid.New(),
                OrderID:   o.ID,
                RefID:     refID,
                Type:      itemType,
                Name:      name,
                Quantity:  qty,
                UnitPrice: unitPrice,
                Total:     total,
        }

        o.Items = append(o.Items, item)
        o.CalculateTotal()
        return nil</span>
}

func (o *Order) CalculateTotal() <span class="cov8" title="1">{
        var totalService, totalParts float64

        for _, item := range o.Items </span><span class="cov8" title="1">{
                if item.Type == ItemTypeService </span><span class="cov8" title="1">{
                        totalService += float64(item.Total)
                }</span> else<span class="cov8" title="1"> {
                        totalParts += float64(item.Total)
                }</span>
        }

        <span class="cov8" title="1">o.TotalService = sharedkernel.Money(totalService)
        o.TotalParts = sharedkernel.Money(totalParts)
        o.Total = sharedkernel.Money(totalService + totalParts)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package domain

import (
        "errors"
        "time"

        "github.com/noggrj/autorepair/internal/sharedkernel"
        "github.com/google/uuid"
)

var (
        ErrServiceNotFound = errors.New("service not found")
)

type Service struct {
        ID          uuid.UUID
        Name        string
        Description string
        Price       sharedkernel.Money
        CreatedAt   time.Time
        UpdatedAt   time.Time
}

func NewService(name, description string, price float64) (*Service, error) <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                return nil, errors.New("name is required")
        }</span>
        <span class="cov8" title="1">if price &lt; 0 </span><span class="cov8" title="1">{
                return nil, errors.New("price cannot be negative")
        }</span>

        <span class="cov8" title="1">return &amp;Service{
                ID:          uuid.New(),
                Name:        name,
                Description: description,
                Price:       sharedkernel.Money(price),
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }, nil</span>
}

type ServiceRepository interface {
        Save(service *Service) error
        GetByID(id uuid.UUID) (*Service, error)
        List() ([]*Service, error)
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package domain

import (
        "errors"
        "time"

        "github.com/noggrj/autorepair/internal/sharedkernel"
        "github.com/google/uuid"
)

var (
        ErrVehicleNotFound = errors.New("vehicle not found")
)

type Vehicle struct {
        ID        uuid.UUID
        ClientID  uuid.UUID
        Plate     sharedkernel.PlacaBR
        Brand     string
        Model     string
        Year      int
        CreatedAt time.Time
        UpdatedAt time.Time
}

func NewVehicle(clientID uuid.UUID, plate, brand, model string, year int) (*Vehicle, error) <span class="cov8" title="1">{
        if clientID == uuid.Nil </span><span class="cov0" title="0">{
                return nil, errors.New("client id is required")
        }</span>
        <span class="cov8" title="1">if brand == "" || model == "" </span><span class="cov0" title="0">{
                return nil, errors.New("brand and model are required")
        }</span>
        <span class="cov8" title="1">if year &lt; 1900 || year &gt; time.Now().Year()+1 </span><span class="cov8" title="1">{
                return nil, errors.New("invalid year")
        }</span>

        <span class="cov8" title="1">p, err := sharedkernel.NewPlacaBR(plate)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;Vehicle{
                ID:        uuid.New(),
                ClientID:  clientID,
                Plate:     p,
                Brand:     brand,
                Model:     model,
                Year:      year,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }, nil</span>
}

type VehicleRepository interface {
        Save(vehicle *Vehicle) error
        GetByID(id uuid.UUID) (*Vehicle, error)
        ListByClientID(clientID uuid.UUID) ([]*Vehicle, error)
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package infrastructure

import (
        "context"
        "errors"

        "github.com/noggrj/autorepair/internal/service/domain"
        "github.com/noggrj/autorepair/internal/sharedkernel"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
)

type PostgresClientRepository struct {
        db *pgxpool.Pool
}

func NewPostgresClientRepository(db *pgxpool.Pool) *PostgresClientRepository <span class="cov0" title="0">{
        return &amp;PostgresClientRepository{db: db}
}</span>

func (r *PostgresClientRepository) Save(client *domain.Client) error <span class="cov0" title="0">{
        query := `INSERT INTO clients (id, name, document, email, phone, created_at, updated_at)
                  VALUES ($1, $2, $3, $4, $5, $6, $7)
                  ON CONFLICT (id) DO UPDATE SET
                  name = EXCLUDED.name,
                  document = EXCLUDED.document,
                  email = EXCLUDED.email,
                  phone = EXCLUDED.phone,
                  updated_at = EXCLUDED.updated_at`
        _, err := r.db.Exec(context.Background(), query,
                client.ID, client.Name, client.Document.String(), client.Email, client.Phone, client.CreatedAt, client.UpdatedAt)
        return err
}</span>

func (r *PostgresClientRepository) GetByID(id uuid.UUID) (*domain.Client, error) <span class="cov0" title="0">{
        query := `SELECT id, name, document, email, phone, created_at, updated_at FROM clients WHERE id = $1`
        row := r.db.QueryRow(context.Background(), query, id)
        return scanClient(row)
}</span>

func (r *PostgresClientRepository) List() ([]*domain.Client, error) <span class="cov0" title="0">{
        query := `SELECT id, name, document, email, phone, created_at, updated_at FROM clients`
        rows, err := r.db.Query(context.Background(), query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var clients []*domain.Client
        for rows.Next() </span><span class="cov0" title="0">{
                client, err := scanClient(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">clients = append(clients, client)</span>
        }
        <span class="cov0" title="0">return clients, nil</span>
}

func scanClient(row pgx.Row) (*domain.Client, error) <span class="cov0" title="0">{
        var client domain.Client
        var docStr string
        err := row.Scan(&amp;client.ID, &amp;client.Name, &amp;docStr, &amp;client.Email, &amp;client.Phone, &amp;client.CreatedAt, &amp;client.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, domain.ErrClientNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">doc, err := sharedkernel.NewDocumentoBR(docStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err // Should not happen if DB is consistent
        }</span>
        <span class="cov0" title="0">client.Document = doc
        return &amp;client, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package infrastructure

import (
        "context"
        "errors"

        "github.com/google/uuid"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/noggrj/autorepair/internal/service/domain"
        "github.com/noggrj/autorepair/internal/sharedkernel"
)

type PostgresOrderRepository struct {
        db *pgxpool.Pool
}

func NewPostgresOrderRepository(db *pgxpool.Pool) *PostgresOrderRepository <span class="cov0" title="0">{
        return &amp;PostgresOrderRepository{db: db}
}</span>

func (r *PostgresOrderRepository) Save(order *domain.Order) error <span class="cov0" title="0">{
        ctx := context.Background()
        tx, err := r.db.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := tx.Rollback(ctx); err != nil </span><span class="cov0" title="0">{
                        // Log rollback error but don't fail the function
                        _ = err // ignore error
                }</span>
        }()

        // Save Order
        <span class="cov0" title="0">query := `INSERT INTO orders (id, client_id, vehicle_id, status, total_service, total_parts, total, created_at, updated_at, started_at, finished_at)
                  VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
                  ON CONFLICT (id) DO UPDATE SET
                  status = EXCLUDED.status,
                  total_service = EXCLUDED.total_service,
                  total_parts = EXCLUDED.total_parts,
                  total = EXCLUDED.total,
                  updated_at = EXCLUDED.updated_at,
                  started_at = EXCLUDED.started_at,
                  finished_at = EXCLUDED.finished_at`

        _, err = tx.Exec(ctx, query,
                order.ID, order.ClientID, order.VehicleID, order.Status,
                float64(order.TotalService), float64(order.TotalParts), float64(order.Total),
                order.CreatedAt, order.UpdatedAt, order.StartedAt, order.FinishedAt)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Save Items (Naive approach: delete all and recreate for simplicity in MVP update)
        // For Create, insert is enough. For Update, delete+insert is easiest for MVP.
        <span class="cov0" title="0">_, err = tx.Exec(ctx, "DELETE FROM order_items WHERE order_id = $1", order.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">itemQuery := `INSERT INTO order_items (id, order_id, ref_id, type, name, quantity, unit_price, total)
                      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`

        for _, item := range order.Items </span><span class="cov0" title="0">{
                _, err = tx.Exec(ctx, itemQuery,
                        item.ID, item.OrderID, item.RefID, item.Type, item.Name,
                        item.Quantity, float64(item.UnitPrice), float64(item.Total))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return tx.Commit(ctx)</span>
}

func (r *PostgresOrderRepository) GetByID(id uuid.UUID) (*domain.Order, error) <span class="cov0" title="0">{
        query := `SELECT id, client_id, vehicle_id, status, total_service, total_parts, total, created_at, updated_at, started_at, finished_at 
                  FROM orders WHERE id = $1`

        row := r.db.QueryRow(context.Background(), query, id)

        var o domain.Order
        var ts, tp, t float64
        var statusStr string

        err := row.Scan(&amp;o.ID, &amp;o.ClientID, &amp;o.VehicleID, &amp;statusStr, &amp;ts, &amp;tp, &amp;t, &amp;o.CreatedAt, &amp;o.UpdatedAt, &amp;o.StartedAt, &amp;o.FinishedAt)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, domain.ErrOrderNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">o.Status = domain.OrderStatus(statusStr)
        o.TotalService = sharedkernel.Money(ts)
        o.TotalParts = sharedkernel.Money(tp)
        o.Total = sharedkernel.Money(t)

        // Fetch Items
        itemsQuery := `SELECT id, order_id, ref_id, type, name, quantity, unit_price, total FROM order_items WHERE order_id = $1`
        rows, err := r.db.Query(context.Background(), itemsQuery, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var i domain.OrderItem
                var typeStr string
                var up, tot float64
                if err := rows.Scan(&amp;i.ID, &amp;i.OrderID, &amp;i.RefID, &amp;typeStr, &amp;i.Name, &amp;i.Quantity, &amp;up, &amp;tot); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">i.Type = domain.OrderItemType(typeStr)
                i.UnitPrice = sharedkernel.Money(up)
                i.Total = sharedkernel.Money(tot)
                o.Items = append(o.Items, &amp;i)</span>
        }

        <span class="cov0" title="0">return &amp;o, nil</span>
}

func (r *PostgresOrderRepository) List() ([]*domain.Order, error) <span class="cov0" title="0">{
        // Basic listing without pagination for MVP
        query := `SELECT id, client_id, vehicle_id, status, total_service, total_parts, total, created_at, updated_at, started_at, finished_at FROM orders`
        rows, err := r.db.Query(context.Background(), query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var orders []*domain.Order
        for rows.Next() </span><span class="cov0" title="0">{
                var o domain.Order
                var ts, tp, t float64
                var statusStr string
                err := rows.Scan(&amp;o.ID, &amp;o.ClientID, &amp;o.VehicleID, &amp;statusStr, &amp;ts, &amp;tp, &amp;t, &amp;o.CreatedAt, &amp;o.UpdatedAt, &amp;o.StartedAt, &amp;o.FinishedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">o.Status = domain.OrderStatus(statusStr)
                o.TotalService = sharedkernel.Money(ts)
                o.TotalParts = sharedkernel.Money(tp)
                o.Total = sharedkernel.Money(t)
                orders = append(orders, &amp;o)</span>
        }
        <span class="cov0" title="0">return orders, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package infrastructure

import (
        "context"
        "errors"

        "github.com/noggrj/autorepair/internal/service/domain"
        "github.com/noggrj/autorepair/internal/sharedkernel"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
)

type PostgresServiceRepository struct {
        db *pgxpool.Pool
}

func NewPostgresServiceRepository(db *pgxpool.Pool) *PostgresServiceRepository <span class="cov0" title="0">{
        return &amp;PostgresServiceRepository{db: db}
}</span>

func (r *PostgresServiceRepository) Save(service *domain.Service) error <span class="cov0" title="0">{
        query := `INSERT INTO services (id, name, description, price, created_at, updated_at)
                  VALUES ($1, $2, $3, $4, $5, $6)
                  ON CONFLICT (id) DO UPDATE SET
                  name = EXCLUDED.name,
                  description = EXCLUDED.description,
                  price = EXCLUDED.price,
                  updated_at = EXCLUDED.updated_at`
        _, err := r.db.Exec(context.Background(), query,
                service.ID, service.Name, service.Description, float64(service.Price), service.CreatedAt, service.UpdatedAt)
        return err
}</span>

func (r *PostgresServiceRepository) GetByID(id uuid.UUID) (*domain.Service, error) <span class="cov0" title="0">{
        query := `SELECT id, name, description, price, created_at, updated_at FROM services WHERE id = $1`
        row := r.db.QueryRow(context.Background(), query, id)
        return scanService(row)
}</span>

func (r *PostgresServiceRepository) List() ([]*domain.Service, error) <span class="cov0" title="0">{
        query := `SELECT id, name, description, price, created_at, updated_at FROM services`
        rows, err := r.db.Query(context.Background(), query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var services []*domain.Service
        for rows.Next() </span><span class="cov0" title="0">{
                s, err := scanService(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">services = append(services, s)</span>
        }
        <span class="cov0" title="0">return services, nil</span>
}

func scanService(row pgx.Row) (*domain.Service, error) <span class="cov0" title="0">{
        var s domain.Service
        var price float64
        err := row.Scan(&amp;s.ID, &amp;s.Name, &amp;s.Description, &amp;price, &amp;s.CreatedAt, &amp;s.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, domain.ErrServiceNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">s.Price = sharedkernel.Money(price)
        return &amp;s, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package infrastructure

import (
        "context"
        "errors"

        "github.com/noggrj/autorepair/internal/service/domain"
        "github.com/noggrj/autorepair/internal/sharedkernel"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
)

type PostgresVehicleRepository struct {
        db *pgxpool.Pool
}

func NewPostgresVehicleRepository(db *pgxpool.Pool) *PostgresVehicleRepository <span class="cov0" title="0">{
        return &amp;PostgresVehicleRepository{db: db}
}</span>

func (r *PostgresVehicleRepository) Save(vehicle *domain.Vehicle) error <span class="cov0" title="0">{
        query := `INSERT INTO vehicles (id, client_id, plate, brand, model, year, created_at, updated_at)
                  VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
                          ON CONFLICT (id) DO UPDATE SET
                          plate = EXCLUDED.plate,
                          brand = EXCLUDED.brand,
                          model = EXCLUDED.model,
                          year = EXCLUDED.year,
                          updated_at = EXCLUDED.updated_at`
        _, err := r.db.Exec(context.Background(), query,
                vehicle.ID, vehicle.ClientID, vehicle.Plate.String(), vehicle.Brand, vehicle.Model, vehicle.Year, vehicle.CreatedAt, vehicle.UpdatedAt)
        return err
}</span>

func (r *PostgresVehicleRepository) GetByID(id uuid.UUID) (*domain.Vehicle, error) <span class="cov0" title="0">{
        query := `SELECT id, client_id, plate, brand, model, year, created_at, updated_at FROM vehicles WHERE id = $1`
        row := r.db.QueryRow(context.Background(), query, id)
        return scanVehicle(row)
}</span>

func (r *PostgresVehicleRepository) ListByClientID(clientID uuid.UUID) ([]*domain.Vehicle, error) <span class="cov0" title="0">{
        query := `SELECT id, client_id, plate, brand, model, year, created_at, updated_at FROM vehicles WHERE client_id = $1`
        rows, err := r.db.Query(context.Background(), query, clientID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var vehicles []*domain.Vehicle
        for rows.Next() </span><span class="cov0" title="0">{
                v, err := scanVehicle(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">vehicles = append(vehicles, v)</span>
        }
        <span class="cov0" title="0">return vehicles, nil</span>
}

func scanVehicle(row pgx.Row) (*domain.Vehicle, error) <span class="cov0" title="0">{
        var v domain.Vehicle
        var plateStr string
        err := row.Scan(&amp;v.ID, &amp;v.ClientID, &amp;plateStr, &amp;v.Brand, &amp;v.Model, &amp;v.Year, &amp;v.CreatedAt, &amp;v.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, domain.ErrVehicleNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">plate, err := sharedkernel.NewPlacaBR(plateStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">v.Plate = plate
        return &amp;v, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package sharedkernel

import (
        "encoding/json"
        "errors"
        "regexp"
)

var (
        ErrInvalidDocument = errors.New("invalid document format")
)

type DocumentoBR struct {
        value string
}

func NewDocumentoBR(doc string) (DocumentoBR, error) <span class="cov8" title="1">{
        // Simplified validation: check length and numeric
        // In production, should implement full digit check (mod 11)
        clean := regexp.MustCompile(`[^0-9]`).ReplaceAllString(doc, "")
        
        if len(clean) != 11 &amp;&amp; len(clean) != 14 </span><span class="cov8" title="1">{
                return DocumentoBR{}, ErrInvalidDocument
        }</span>
        
        <span class="cov8" title="1">return DocumentoBR{value: clean}, nil</span>
}

func (d DocumentoBR) String() string <span class="cov8" title="1">{
        return d.value
}</span>

func (d DocumentoBR) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(d.value)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package sharedkernel

import (
        "encoding/json"
        "errors"
        "regexp"
        "strings"
)

var (
        ErrInvalidPlate = errors.New("invalid plate format")
)

type PlacaBR struct {
        value string
}

func NewPlacaBR(plate string) (PlacaBR, error) <span class="cov8" title="1">{
        upper := strings.ToUpper(strings.ReplaceAll(plate, "-", ""))
        
        // Legacy: AAA1234 (3 letters, 4 numbers)
        // Mercosul: AAA1A23 (3 letters, 1 number, 1 letter, 2 numbers)
        legacyRegex := regexp.MustCompile(`^[A-Z]{3}[0-9]{4}$`)
        mercosulRegex := regexp.MustCompile(`^[A-Z]{3}[0-9][A-Z][0-9]{2}$`)

        if !legacyRegex.MatchString(upper) &amp;&amp; !mercosulRegex.MatchString(upper) </span><span class="cov8" title="1">{
                return PlacaBR{}, ErrInvalidPlate
        }</span>

        <span class="cov8" title="1">return PlacaBR{value: upper}, nil</span>
}

func (p PlacaBR) String() string <span class="cov8" title="1">{
        return p.value
}</span>

func (p PlacaBR) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(p.value)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package main

import (
        "log"

        "github.com/noggrj/autorepair/internal/identity/domain"
        "github.com/noggrj/autorepair/internal/identity/infrastructure"
        "github.com/noggrj/autorepair/internal/platform/config"
        "github.com/noggrj/autorepair/internal/platform/db"
)

func main() <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load config: %v", err)
        }</span>

        <span class="cov0" title="0">pool, err := db.New(cfg.DBURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">defer pool.Close()

        userRepo := infrastructure.NewPostgresUserRepository(pool.Pool)

        adminEmail := "admin@autorepair.com"
        adminPassword := "admin123"

        // Check if admin exists
        _, err = userRepo.GetByEmail(adminEmail)
        if err == nil </span><span class="cov0" title="0">{
                log.Println("Admin user already exists")
                return
        }</span>

        <span class="cov0" title="0">user, err := domain.NewUser("Admin User", adminEmail, adminPassword, domain.RoleAdmin)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">if err := userRepo.Save(user); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">log.Println("Admin user created successfully")</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
